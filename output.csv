Jagannath University,,,,,,,,,,,,,,,,,,,,,,,
Department: Computer Science & Engineering,,,,,,,,,,,,,,,,,,,,,,,
Name : Mosammat Shima Aktar,,,,,,,,,,,,,,,,,,,,,,,
ID: B190305024,,,,,,,,,,,,,,,,,,,,,,,
Course Name: Data Structure,,,,,,,,,,,,,,,,,,,,,,,
Course Code: CSE-1203,,,,,,,,,,,,,,,,,,,,,,,
Question 1: When Floyd Warshall Algorithm is used? Give an Example based on,,,,,,,,,,,,,,,,,,,,,,,
Warshall Algorith.,,,,,,,,,,,,,,,,,,,,,,,
Answer :,,,,,,,,,,,,,,,,,,,,,,,
Floyd Warshall Algorithm is a famous algorithm. It is used to solve ‚ÄúAll Pairs shortest Path Problem‚Äù. Floyd,,,,,,,,,,,,,,,,,,,,,,,
Warshall Algorithm is an example of dynamic programming approach. It is best suited for dense graphs.,,,,,,,,,,,,,,,,,,,,,,,
This is because it‚Äôs complexity depends only on the number of vertices in the given graph.,,,,,,,,,,,,,,,,,,,,,,,
Requirements:,ÔÇ∑ Graph must be a weighted directed graph.,ÔÇ∑ Edge weights can be positive or negative.,ÔÇ∑ There should be no negative cycles. (A negative cycle is a cycle whose edges sum to a negative,value.),,,,,,,,,,,,,,,,,,,
Time Complexity:,,,,,,,,,,,,,,,,,,,,,,,
The algorithm consists of three loops over all nodes and the most inner loop contains only operation of a,constant complexity.,,,,,,,,,,,,,,,,,,,,,,
Hence The asymptotic complexity of the whole Floyd Warshall Algorithm is,,,,,,,,,,,,,,,,,,,,,,,
O(|ùëÅ|^3) where |ùëÅ| is the number of nodes in the graph.,,,,,,,,,,,,,,,,,,,,,,,
Example:,,,,,,,,,,,,,,,,,,,,,,,
Initial distance Matrix for the given graph is :,,,,,,,,,,,,,,,,,,,,,,,
"Using Floyd Warshall Algorithm ,we can write the following 4 matrices ‚Äì",,,,,,,,,,,,,,,,,,,,,,,
The last matrix ùê∑ represents the shortest path distance between every pair of vertices.,4,,,,,,,,,,,,,,,,,,,,,,
"In the above problem, there are 4 vertices in the graph, So there will be 4 matrices of order 4√ó4 in the",solution excluding the initial distance matrix. Diagonal elements of each matrix will always be 0.,,,,,,,,,,,,,,,,,,,,,,
Question 2: what are the methods to implement queue in C? How the queue is,implemented by linked list?,,,,,,,,,,,,,,,,,,,,,,
Answer:,,,,,,,,,,,,,,,,,,,,,,,
Queue is a linear data structure that maintains a list of elements such that insertion happens at rear end and,deletion happens at front end.,,,,,,,,,,,,,,,,,,,,,,
FIFO ‚Äì First In First Out principle.,,,,,,,,,,,,,,,,,,,,,,,
The methods to implement queues are:,ÔÇ∑ Array based.,ÔÇ∑ Linked list based.,,,,,,,,,,,,,,,,,,,,,
The queue is implemented by linked list is based on the dynamic memory management techniques which,allow allocation and deallocation of memory space at runtime. The major problem with the queue,"implemented using an array is, It will work for an only fixed number of data values. That means, the amount",of data must be specified at the beginning itself. Queue using an array is not suitable when we don't know,the size of data which we are going to use. A queue data structure can be implemented using a linked list,data structure. The queue which is implemented using a linked list can work for an unlimited number of,"values. That means, queue using linked list can work for the variable size of data (No need to fix the size at",the beginning of the implementation). The Queue implemented using linked list can organize as many data,values as we want.,,,,,,,,,,,,,,,
"In linked list implementation of a queue, the last inserted node is always pointed by 'rear' and the first node",is always pointed by 'front'.,,,,,,,,,,,,,,,,,,,,,,
Node structure for Queue,struct node,{,int data;,struct node *next;,};,,,,,,,,,,,,,,,,,,
To point the front and rear node,"struct node *front = NULL, *rear = NULL;",,,,,,,,,,,,,,,,,,,,,,
Enqueue function,,,,,,,,,,,,,,,,,,,,,,,
Enqueue function will add the element at the end of the linked list.,,,,,,,,,,,,,,,,,,,,,,,
"Using the rear pointer, we can track the last inserted element.",1. Declare a new node and allocate memory for it.,"2. If front == NULL,",make both front and rear points to the new node.,"3. Otherwise,",add the new node in rear->next.,make the new node as the rear node. i.e. rear = new node,void enqueue(int val),{,struct node *newNode = malloc(sizeof(struct node));,newNode->data = val;,newNode->next = NULL;,//if it is the first node,if(front == NULL && rear == NULL),//make both front and rear points to the new node,front = rear = newNode;,else,{,//add newnode in rear->next,rear->next = newNode;,//make the new node as the rear node,rear = newNode;,},}
Visual representation of the above algorithm,,,,,,,,,,,,,,,,,,,,,,,
Insert 10,,,,,,,,,,,,,,,,,,,,,,,
Insert 20,,,,,,,,,,,,,,,,,,,,,,,
Insert 30,,,,,,,,,,,,,,,,,,,,,,,
Dequeue function,,,,,,,,,,,,,,,,,,,,,,,
Dequeue function will remove the first element from the queue.,1.Check whether the queue is empty or not,2.If it is the empty queue (front == NULL),,,,,,,,,,,,,,,,,,,,,
We can't dequeue the element.,"3.Otherwise,",,,,,,,,,,,,,,,,,,,,,,
Make the front node points to the next node. i.e front = front->next;,"if front pointer becomes NULL, set the rear pointer also NULL.",,,,,,,,,,,,,,,,,,,,,,
Free the front node's memory.,void dequeue(),{,//used to freeing the first node after dequeue,struct node *temp;,if(front == NULL),"printf(""Queue is Empty. Unable to perform dequeue\n"");",else,{,//take backup,temp = front;,//make the front node points to the next node,//logically removing the front element,front = front->next;,"//if front == NULL, set rear = NULL",if(front == NULL),rear = NULL;,//free the first node,free(temp);,},},,,
This is how we can implement queue using Linked list.,,,,,,,,,,,,,,,,,,,,,,,
Question 3: How the insertion sort is done with the array? Which sorting method is,better among bubble sort and counting sort?,,,,,,,,,,,,,,,,,,,,,,
Answer: Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in,your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are,picked and placed at the correct position in the sorted part.,,,,,,,,,,,,,,,,,,,,,
Algorithm,,,,,,,,,,,,,,,,,,,,,,,
To sort an array of size n in ascending order:,1: Iterate from arr[1] to arr[n] over the array.,2: Compare the current element (key) to its predecessor.,"3: If the key element is smaller than its predecessor, compare it to the elements before. Move the greater",elements one position up to make space for the swapped element.,,,,,,,,,,,,,,,,,,,
Example:,,,,,,,,,,,,,,,,,,,,,,,
Another Example:,"12, 11, 13, 5, 6",,,,,,,,,,,,,,,,,,,,,,
Let us loop for i = 1 (second element of the array) to 4 (last element of the array),"i = 1. Since 11 is smaller than 12, move 12 and insert 11 before 12","11, 12, 13, 5, 6",i = 2. 13 will remain at its position as all elements in A[0..I-1] are smaller than 13,"11, 12, 13, 5, 6",i = 3. 5 will move to the beginning and all other elements from 11 to 13 will move one position ahead of,their current position.,"5, 11, 12, 13, 6","i = 4. 6 will move to position after 5, and elements from 11 to 13 will move one position ahead of their",current position.,"5, 6, 11, 12, 13",,,,,,,,,,,,,
Bubble sort:,,,,,,,,,,,,,,,,,,,,,,,
Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in,wrong order.,,,,,,,,,,,,,,,,,,,,,,
Example:,,,,,,,,,,,,,,,,,,,,,,,
First Pass:,"( 5 1 4 2 8 ) ‚Äì> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1.","( 1 5 4 2 8 ) ‚Äì> ( 1 4 5 2 8 ), Swap since 5 > 4","( 1 4 5 2 8 ) ‚Äì> ( 1 4 2 5 8 ), Swap since 5 > 2","( 1 4 2 5 8 ) ‚Äì> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.",,,,,,,,,,,,,,,,,,,
Second Pass:,( 1 4 2 5 8 ) ‚Äì> ( 1 4 2 5 8 ),"( 1 4 2 5 8 ) ‚Äì> ( 1 2 4 5 8 ), Swap since 4 > 2",( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),,,,,,,,,,,,,,,,,,,
"Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole",pass without any swap to know it is sorted.,,,,,,,,,,,,,,,,,,,,,,
Third Pass:,( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),( 1 2 4 5 8 ) ‚Äì> ( 1 2 4 5 8 ),,,,,,,,,,,,,,,,,,,
Counting sort:,,,,,,,,,,,,,,,,,,,,,,,
Counting sort is a sorting technique based on keys between a specific range. It works by counting the number of,objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each,object in the output sequence.,,,,,,,,,,,,,,,,,,,,,
Let us understand it with the help of an example.,,,,,,,,,,,,,,,,,,,,,,,
"For simplicity, consider the data in the range 0 to 9.",,,,,,,,,,,,,,,,,,,,,,,
"Input data: 1, 4, 1, 2, 7, 5, 2",1) Take a count array to store the count of each unique object.,,,,,,,,,,,,,,,,,,,,,,
Index: 0 1 2 3 4 5 6 7 8 9,,,,,,,,,,,,,,,,,,,,,,,
Count: 0 2 2 0 1 1 0 1 0 0,2) Modify the count array such that each element at each index,stores the sum of previous counts.,,,,,,,,,,,,,,,,,,,,,
Index: 0 1 2 3 4 5 6 7 8 9,,,,,,,,,,,,,,,,,,,,,,,
Count: 0 2 4 4 5 6 6 7 7 7,,,,,,,,,,,,,,,,,,,,,,,
The modified count array indicates the position of each object in,the output sequence.,3) Output each object from the input sequence followed by,decreasing its count by 1.,,,,,,,,,,,,,,,,,,,,
"Process the input data: 1, 4, 1, 2, 7, 5, 2. Position of 1 is 2.",,,,,,,,,,,,,,,,,,,,,,,
Put data 1 at index 2 in output. Decrease count by 1 to place,next data 1 at an index 1 smaller than this index.,,,,,,,,,,,,,,,,,,,,,,
We know that the time complexity of bubble sort is O(ùëõ2) where complexity of counting sort is O(n) with,"space proportional to the range of data. So the counting sort complexity is O(n+k). So we can say, counting","sort is very efficient, stable sorting algorithm.",,,,,,,,,,,,,,,,,,,,,
